<script type="module">
    document.addEventListener('DOMContentLoaded', () => {
        // --- App State & Configuration ---
        const state = {
            // ... (keep your other state properties) ...

            // REMOVE aPI KEY FROM STATE
            // geminiApiKey: "", // This is now handled securely on the backend

            // ... (the rest of your state object) ...
        };

        // ... (keep all other functions like init, checkUser, etc.) ...


        // REPLACE THIS ENTIRE FUNCTION
        const generateLeadsWithAI = async (prompt) => {
            const searchPrompt = `As a sales intelligence tool, perform a web search to find real companies based on this request: "${prompt}". Provide the results as a JSON array. Each object must have 'company' (the real company name), 'domain' (their actual website domain), 'status': 'New', 'source': 'Web Search', and 'date'. Output ONLY the JSON array.`;

            const response = await fetch('/.netlify/functions/generateWithGemini', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: searchPrompt }),
            });

            if (!response.ok) throw new Error(`API call failed: ${response.statusText}`);
            const data = await response.json();
            const textContent = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!textContent) throw new Error("No content received from AI.");

            let jsonString = textContent.trim().replace(/^```json\s*|```$/g, '');
            const generatedLeads = JSON.parse(jsonString);

            const newLeads = (Array.isArray(generatedLeads) ? generatedLeads : [generatedLeads]).map(lead => ({
                id: generateUniqueId(),
                company: lead.company || 'Unknown Company',
                domain: lead.domain || '',
                status: lead.status || 'New',
                source: 'AI Web Search',
                date: lead.date || new Date().toISOString().split('T')[0],
                contacts: [] // Initialize with empty contacts
            }));

            state.leads = [...state.leads, ...newLeads];
            saveState();
            renderLeadsTable();
        };

        // REPLACE THIS ENTIRE FUNCTION
        const generateContactsWithAI = async (companyName, domain) => {
            const searchPrompt = `As a sales intelligence tool, perform a targeted web search for the leadership team at "${companyName}" (website: ${domain}). Find 2-3 real, key decision-makers (like CEO, VP of Sales, CTO, Head of Marketing). Provide the results as a JSON array of objects, each with "name" and "title". Output ONLY the JSON array.`;

            const response = await fetch('/.netlify/functions/generateWithGemini', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: searchPrompt }),
            });

            if (!response.ok) throw new Error(`API call failed: ${response.statusText}`);
            const data = await response.json();
            const textContent = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!textContent) throw new Error("No content received from AI for contacts.");

            let jsonString = textContent.trim().replace(/^```json\s*|```$/g, '');
            return JSON.parse(jsonString);
        };

        // REPLACE THIS ENTIRE FUNCTION
        const generateAIOpportunityAnalysis = async (
            companyName, estimatedValue, stage, type, totalMonthlyShippingSpend,
            currentEquipment, currentProduct, competitiveProduct, clientType
        ) => {
            const productsList = state.pitneyProducts.join(', ');
            let promptText = `Analyze a sales opportunity for ${companyName} (Estimated Value: $${estimatedValue.toLocaleString()}, Stage: ${stage}, Type: ${type}).
                Client Details: Monthly Shipping Spend: $${totalMonthlyShippingSpend.toLocaleString()}, Current Equipment: "${currentEquipment}", Client Type: "${clientType}".`;

            if (currentProduct && clientType === 'Organic') {
                promptText += ` Current Pitney Bowes Product: "${currentProduct}".`;
            } else if (competitiveProduct && clientType === 'Competitive') {
                promptText += ` Competitive Product in use: "${competitiveProduct}".`;
            }

            promptText += `\nProvide an analysis in JSON format with the following fields:
                - opportunityScore (number, 0-100): Overall score for the opportunity.
                - predictedWinRate (number, 0-100): Predicted win rate percentage.
                - recommendedProduct (string): Recommend one product from this exact list: [${productsList}]. Choose the best fit based on details.
                - companyIntel (string): 2-3 sentences of general company intelligence.
                - strategicSummary (string): 2-3 sentences summarizing the sales strategy.
                - nextBestAction (string): 1 sentence for the immediate next best action for the sales rep.
                - potentialRisks (array of strings): 1-3 potential risks.
                - personalizedValueProposition (string): 2-3 sentences for a tailored value proposition.
                - autoGeneratedEmail (object): An object with 'subject' (string) and 'body' (string) for a follow-up email.
                Do not include any other text or markdown outside the JSON object.`;

            const response = await fetch('/.netlify/functions/generateWithGemini', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: promptText }),
            });

            if (!response.ok) {
                 const errorText = await response.text();
                 throw new Error(`AI analysis failed: ${errorText}`);
            }

            const data = await response.json();
            if (data.promptFeedback && data.promptFeedback.blockReason) {
                throw new Error(`Your prompt was blocked by safety filters: ${data.promptFeedback.blockReason}.`);
            }
            const textContent = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!textContent) {
                throw new Error("No content received from AI analysis.");
            }

            let analysisResult;
            try {
                analysisResult = JSON.parse(textContent);
            } catch (parseError) {
                console.error("Failed to parse JSON from AI analysis response:", textContent, parseError);
                throw new Error("AI analysis response was not valid JSON.");
            }

            const finalRecommendedProduct = state.pitneyProducts.includes(analysisResult.recommendedProduct) ? analysisResult.recommendedProduct : state.pitneyProducts[0];
            const finalOpportunityScore = Math.max(0, Math.min(100, parseInt(analysisResult.opportunityScore) || 0));
            const finalPredictedWinRate = Math.max(0, Math.min(100, parseInt(analysisResult.predictedWinRate) || 0));

            return {
                opportunityScore: finalOpportunityScore,
                predictedWinRate: finalPredictedWinRate,
                recommendedProduct: finalRecommendedProduct,
                companyIntel: analysisResult.companyIntel || "AI couldn't generate specific company intelligence.",
                strategicSummary: analysisResult.strategicSummary || "AI couldn't generate a strategic summary.",
                nextBestAction: analysisResult.nextBestAction || "AI couldn't suggest a next best action.",
                potentialRisks: Array.isArray(analysisResult.potentialRisks) ? analysisResult.potentialRisks : [],
                personalizedValueProposition: analysisResult.personalizedValueProposition || "AI couldn't generate a personalized value proposition.",
                autoGeneratedEmail: {
                    subject: analysisResult.autoGeneratedEmail?.subject || "Follow-up on Your Business Needs",
                    body: analysisResult.autoGeneratedEmail?.body || "Dear [Contact Name],\n\nFurther to our discussion, please find some potential solutions attached.\n\nBest regards,\n" + state.currentUser
                }
            };
        };

        // ... (keep all remaining functions) ...

        init();
    });
</script>